- fill in CouenneSolverInterface class
- check if z_nlp=z_lp ==> fathom and return x_nlp as feas solution of node
- implied/propagated bounds to follow graph and not enumerated for all variables (for huge instances)
- implied bounds, branching rule, getfixvar and sparsity graph for exprQuad
- Fix excessively large coefficients
- Fix branching point, sometimes too close to current bound
- recognize convex objectives/constraints and apply OA as extra cuts (still keep symbolic info)
- change chg_bds structure within createCuts when add colCut
- apply bound tightening AFTER applying branching rule but BEFORE re-solving LP
- decompose quad form if block diagonal ONLY when looking for $\alpha_i$ (Jon), then use joint convexification
- field quadCut_ for each expression (unary too! eg exp (log (x)) gives gap), especially prod/sum/div
- similarity () method to check degree of similarity in expressions (1 if compare() gives true)
- check common subexpressions in different constraints (e.g. min {x^2 + y^2: xy >=3} can use quad cut)
- quadratic approximation of expression subtree (see Nowak's approximation with lb/ub of Hessian)
- Bilinear cuts
- variable lhs/rhs of bounds containing expression defining aux vars
- cut currValue_ from expressions
- documentation
- add integrality to bound check
- decomposition approach
- unify products and divisions
- linear convexification has an acyclic structure where x are leaves. How to exploit it?
- recognition of quadratic forms
- (reverse Polish notation)-based evaluation, for efficiency
- create CouenneTMINLP interface for Ipopt
- separate function evaluation lib from convexification
- QQP convexification
- MILP + MINLP for some operators
