<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Bonmin: Bonmin::TMINLP Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bonmin
   &#160;<span id="projectnumber">1.7</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_bonmin.html">Bonmin</a>      </li>
      <li class="navelem"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html">TMINLP</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Bonmin::TMINLP Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Bonmin::TMINLP" -->
<p>Base class for all MINLPs that use a standard triplet matrix form and dense vectors.  
 <a href="class_bonmin_1_1_t_m_i_n_l_p.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Bonmin::TMINLP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_bonmin_1_1_t_m_i_n_l_p.png" usemap="#Bonmin::TMINLP_map" alt=""/>
  <map id="Bonmin::TMINLP_map" name="Bonmin::TMINLP_map">
<area href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html" title="Ampl MINLP Interface." alt="Bonmin::AmplTMINLP" shape="rect" coords="0,56,141,80"/>
<area href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html" title="From a TMINLP, this class adapts to another TMINLP where the original objective is transformed into a..." alt="Bonmin::TMINLPLinObj" shape="rect" coords="151,56,292,80"/>
<area href="class_my_t_m_i_n_l_p.html" title="A C++ example for interfacing an MINLP with bonmin." alt="MyTMINLP" shape="rect" coords="302,56,443,80"/>
</map>
 </div></div>

<p><a href="class_bonmin_1_1_t_m_i_n_l_p-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_branching_info.html">BranchingInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores branching priorities information.  <a href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_branching_info.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_marked_non_convex.html">MarkedNonConvex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for marked non-convex constraints.  <a href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_marked_non_convex.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_1_1_perturb_info.html">PerturbInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to store perturbation radii for variables in the model.  <a href="class_bonmin_1_1_t_m_i_n_l_p_1_1_perturb_info.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_simple_concave_constraint.html">SimpleConcaveConstraint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure which describes a constraints of the form $f[ y  F(x) ] with <img class="formulaInl" alt="$ F(x) $" src="form_3.png"/> a concave function.  <a href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_simple_concave_constraint.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_sos_info.html">SosInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to store sos constraints for model.  <a href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_sos_info.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aa">SolverReturn</a> { <br/>
&#160;&#160;<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aaae94d14866883a07057ce24fcc574c709">SUCCESS</a>, 
<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aaa1422a0ad80454057a222e5b26fd1b60c">INFEASIBLE</a>, 
<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aaa8f7f2d7601e069d44f118f19eea81159">CONTINUOUS_UNBOUNDED</a>, 
<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aaad4d3d141fac7ef0533cb6db33808ac62">LIMIT_EXCEEDED</a>, 
<br/>
&#160;&#160;<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aaa129fe08148d5a5d6d1ee0eb1d874ba5c">USER_INTERRUPT</a>, 
<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aaac87dd577ef9d8195ba1420d2bca0e7cd">MINLP_ERROR</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return statuses of algorithm.  <a href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aa">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a31ed0c3e4cdb5479e0d4a3bec1a5ae09">VariableType</a> { <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a31ed0c3e4cdb5479e0d4a3bec1a5ae09a07ad1737d2861f380390698a018afb40">CONTINUOUS</a>, 
<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a31ed0c3e4cdb5479e0d4a3bec1a5ae09ad73b3452f6e6aee8659d854a1803a73b">BINARY</a>, 
<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a31ed0c3e4cdb5479e0d4a3bec1a5ae09a47f6c2e4d46ac39986728bf2adf419c2">INTEGER</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the variables.  <a href="class_bonmin_1_1_t_m_i_n_l_p.html#a31ed0c3e4cdb5479e0d4a3bec1a5ae09">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a1a578ad3281073969b2751c577835872">Convexity</a> { <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a1a578ad3281073969b2751c577835872a9f24551f3b3830c058baefee74bbed24">Convex</a>, 
<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a1a578ad3281073969b2751c577835872a2f1f415ce8e21ffcb3c43b83aad76ddd">NonConvex</a>, 
<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a1a578ad3281073969b2751c577835872a64065b9c897f109cc5e4e394e074e940">SimpleConcave</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to mark constraints of the problem.  <a href="class_bonmin_1_1_t_m_i_n_l_p.html#a1a578ad3281073969b2751c577835872">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_branching_info.html">BranchingInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a0411c4f260997488ac7730844da708e0">branchingInfo</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_sos_info.html">SosInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#acd6b2feac68461ea9017e66897f21e90">sosConstraints</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_1_1_perturb_info.html">PerturbInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a8de73cde089588281f08b5efc6fa7bca">perturbInfo</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a46d0ccf29f7f0a6ab0e407d0f59c9fc3">hasUpperBoundingObjective</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Say if has a specific function to compute upper bounds.  <a href="#a46d0ccf29f7f0a6ab0e407d0f59c9fc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a6e561bc269d70d94457ae0bf9849f383">eval_upper_bound_f</a> (Ipopt::Index n, const Ipopt::Number *x, Ipopt::Number &amp;obj_value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return the value of an alternative objective function for upper bounding (to use it hasUpperBoundingObjective should return true).  <a href="#a6e561bc269d70d94457ae0bf9849f383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#ad06ab84cbdd03fcda2987b5bb22ae287">get_constraint_convexities</a> (int m, <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a1a578ad3281073969b2751c577835872">TMINLP::Convexity</a> *constraints_convexities) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get accest to constraint convexities.  <a href="#ad06ab84cbdd03fcda2987b5bb22ae287"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af1185094c0a8d14b23f48478e80fa9d4">get_number_nonconvex</a> (int &amp;number_non_conv, int &amp;number_concave) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get dimension information on nonconvex constraints.  <a href="#af1185094c0a8d14b23f48478e80fa9d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a59fdbfe7e50ac4c0904b3c4c77735c23">get_constraint_convexities</a> (int number_non_conv, <a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_marked_non_convex.html">MarkedNonConvex</a> *non_convs) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get array describing the constraints marked nonconvex in the model.  <a href="#a59fdbfe7e50ac4c0904b3c4c77735c23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#aa4cbe58a5ec3fabaf15cc721740d52a8">get_simple_concave_constraints</a> (int number_concave, <a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_simple_concave_constraint.html">SimpleConcaveConstraint</a> *simple_concave) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill array containing indices of simple concave constraints.  <a href="#aa4cbe58a5ec3fabaf15cc721740d52a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a3d11768108279a123da4ba254d62b683">hasLinearObjective</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Say if problem has a linear objective (for OA)  <a href="#a3d11768108279a123da4ba254d62b683"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a8ced9cfd6a40dc99b6d441b10c9a2ed5">hasGeneralInteger</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Say if problem has general integer variables.  <a href="#a8ced9cfd6a40dc99b6d441b10c9a2ed5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a8aa206c04ebd20610d9f196796f1ab2d">get_const_xtra_id</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access array describing constraint to which perspectives should be applied.  <a href="#a8aa206c04ebd20610d9f196796f1ab2d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors/Destructors</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#ab47c82ceca30aa9ebffd97442b74f0f3">TMINLP</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#ab47c82ceca30aa9ebffd97442b74f0f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a7b0df23b5d25380acd2358bae697f699">~TMINLP</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#a7b0df23b5d25380acd2358bae697f699"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">methods to gather information about the MINLP</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#afe3e7dc4d980a18aa5ece4168d98e235">get_nlp_info</a> (Ipopt::Index &amp;n, Ipopt::Index &amp;m, Ipopt::Index &amp;nnz_jac_g, Ipopt::Index &amp;nnz_h_lag, Ipopt::TNLP::IndexStyleEnum &amp;index_style)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return the number of variables and constraints, and the number of non-zeros in the jacobian and the hessian.  <a href="#afe3e7dc4d980a18aa5ece4168d98e235"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a740751ce6ef284604def22fb6e587ea3">get_scaling_parameters</a> (Ipopt::Number &amp;obj_scaling, bool &amp;use_x_scaling, Ipopt::Index n, Ipopt::Number *x_scaling, bool &amp;use_g_scaling, Ipopt::Index m, Ipopt::Number *g_scaling)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return scaling parameters.  <a href="#a740751ce6ef284604def22fb6e587ea3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a8a34a3b8f55889ede85929f8ff4fc870">get_variables_types</a> (Ipopt::Index n, <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a31ed0c3e4cdb5479e0d4a3bec1a5ae09">VariableType</a> *var_types)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to provide the variables types.  <a href="#a8a34a3b8f55889ede85929f8ff4fc870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a4e01017190e373ebe8324074800c043f">get_variables_linearity</a> (Ipopt::Index n, Ipopt::TNLP::LinearityType *var_types)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to provide the variables linearity.  <a href="#a4e01017190e373ebe8324074800c043f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a576125a75942898fd2a584b1c3510388">get_constraints_linearity</a> (Ipopt::Index m, Ipopt::TNLP::LinearityType *const_types)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to provide the constraint linearity.  <a href="#a576125a75942898fd2a584b1c3510388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a71056c07ab8a4ce38d0571f281933688">get_bounds_info</a> (Ipopt::Index n, Ipopt::Number *x_l, Ipopt::Number *x_u, Ipopt::Index m, Ipopt::Number *g_l, Ipopt::Number *g_u)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return the information about the bound on the variables and constraints.  <a href="#a71056c07ab8a4ce38d0571f281933688"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a916ccc55b7ea1ee4daddc4608389cdda">get_starting_point</a> (Ipopt::Index n, bool init_x, Ipopt::Number *x, bool init_z, Ipopt::Number *z_L, Ipopt::Number *z_U, Ipopt::Index m, bool init_lambda, Ipopt::Number *lambda)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return the starting point.  <a href="#a916ccc55b7ea1ee4daddc4608389cdda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#adb99e4c1f8e08afdb786b290d680c06b">eval_f</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number &amp;obj_value)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return the value of the objective function  <a href="#adb99e4c1f8e08afdb786b290d680c06b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#aa796b8a447d261fc32b41dfe8a24a6d4">eval_grad_f</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number *grad_f)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return the vector of the gradient of the objective w.r.t.  <a href="#aa796b8a447d261fc32b41dfe8a24a6d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a68b3a747f68fbec612216cd40426857f">eval_g</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Number *g)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return the vector of constraint values  <a href="#a68b3a747f68fbec612216cd40426857f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a7d0a1f22939a9257a528a8bef98ff3b2">eval_jac_g</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Index nele_jac, Ipopt::Index *iRow, Ipopt::Index *jCol, Ipopt::Number *values)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return the jacobian of the constraints.  <a href="#a7d0a1f22939a9257a528a8bef98ff3b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a88dcf938655472809afd0586e399d0ec">eval_h</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number obj_factor, Ipopt::Index m, const Ipopt::Number *lambda, bool new_lambda, Ipopt::Index nele_hess, Ipopt::Index *iRow, Ipopt::Index *jCol, Ipopt::Number *values)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">overload this method to return the hessian of the lagrangian.  <a href="#a88dcf938655472809afd0586e399d0ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a10e3dcd09b90c6c38f307082ac5af60c">eval_gi</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index i, Ipopt::Number &amp;gi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value of a single constraint.  <a href="#a10e3dcd09b90c6c38f307082ac5af60c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a08432792778b26b6f81c92b678d775bd">eval_grad_gi</a> (Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index i, Ipopt::Index &amp;nele_grad_gi, Ipopt::Index *jCol, Ipopt::Number *values)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the structure or values of the gradient for one constraint.  <a href="#a08432792778b26b6f81c92b678d775bd"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Solution Methods</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a492d05e99cfb915922c933ecae9ed1ab">finalize_solution</a> (<a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aa">TMINLP::SolverReturn</a> status, Ipopt::Index n, const Ipopt::Number *x, Ipopt::Number obj_value)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called when the algorithm is complete so the TNLP can store/write the solution.  <a href="#a492d05e99cfb915922c933ecae9ed1ab"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#ab0e51c30424dca9eeae277119d3abf58">TMINLP</a> (const <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html">TMINLP</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ab0e51c30424dca9eeae277119d3abf58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a12a8af7768290187f961564a582162c9">operator=</a> (const <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html">TMINLP</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded Equals Operator.  <a href="#a12a8af7768290187f961564a582162c9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a65bff206a7e91288f5ec46e0b8990c86">TMINLP2TNLP</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Base class for all MINLPs that use a standard triplet matrix form and dense vectors. </p>
<p>The class <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p2_t_n_l_p.html" title="This is an adapter class that converts a TMINLP to a TNLP to be solved by Ipopt.">TMINLP2TNLP</a> allows the caller to produce a viable TNLP from the MINLP (by relaxing binary and/or integers, or by fixing them), which can then be solved by <a class="el" href="namespace_ipopt.html">Ipopt</a>.</p>
<p>This interface presents the problem form: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{rl} &amp;min f(x)\\ \mbox{s.t.}&amp;\\ &amp; g^L <= g(x) <= g^U\\ &amp; x^L <= x <= x^U\\ \end{array} \]" src="form_2.png"/>
</p>
<p> Where each x_i is either a continuous, binary, or integer variable. If x_i is binary, the bounds [xL,xU] are assumed to be [0,1]. In order to specify an equality constraint, set gL_i = gU_i = rhs. The value that indicates "infinity" for the bounds (i.e. the variable or constraint has no lower bound (-infinity) or upper bound (+infinity)) is set through the option nlp_lower_bound_inf and nlp_upper_bound_inf. To indicate that a variable has no upper or lower bound, set the bound to -ipopt_inf or +ipopt_inf respectively </p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00059">59</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="af637b1924c8559f56075e39448dd12aa"></a><!-- doxytag: member="Bonmin::TMINLP::SolverReturn" ref="af637b1924c8559f56075e39448dd12aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aa">Bonmin::TMINLP::SolverReturn</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return statuses of algorithm. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af637b1924c8559f56075e39448dd12aaae94d14866883a07057ce24fcc574c709"></a><!-- doxytag: member="SUCCESS" ref="af637b1924c8559f56075e39448dd12aaae94d14866883a07057ce24fcc574c709" args="" -->SUCCESS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af637b1924c8559f56075e39448dd12aaa1422a0ad80454057a222e5b26fd1b60c"></a><!-- doxytag: member="INFEASIBLE" ref="af637b1924c8559f56075e39448dd12aaa1422a0ad80454057a222e5b26fd1b60c" args="" -->INFEASIBLE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af637b1924c8559f56075e39448dd12aaa8f7f2d7601e069d44f118f19eea81159"></a><!-- doxytag: member="CONTINUOUS_UNBOUNDED" ref="af637b1924c8559f56075e39448dd12aaa8f7f2d7601e069d44f118f19eea81159" args="" -->CONTINUOUS_UNBOUNDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af637b1924c8559f56075e39448dd12aaad4d3d141fac7ef0533cb6db33808ac62"></a><!-- doxytag: member="LIMIT_EXCEEDED" ref="af637b1924c8559f56075e39448dd12aaad4d3d141fac7ef0533cb6db33808ac62" args="" -->LIMIT_EXCEEDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af637b1924c8559f56075e39448dd12aaa129fe08148d5a5d6d1ee0eb1d874ba5c"></a><!-- doxytag: member="USER_INTERRUPT" ref="af637b1924c8559f56075e39448dd12aaa129fe08148d5a5d6d1ee0eb1d874ba5c" args="" -->USER_INTERRUPT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af637b1924c8559f56075e39448dd12aaac87dd577ef9d8195ba1420d2bca0e7cd"></a><!-- doxytag: member="MINLP_ERROR" ref="af637b1924c8559f56075e39448dd12aaac87dd577ef9d8195ba1420d2bca0e7cd" args="" -->MINLP_ERROR</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00064">64</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31ed0c3e4cdb5479e0d4a3bec1a5ae09"></a><!-- doxytag: member="Bonmin::TMINLP::VariableType" ref="a31ed0c3e4cdb5479e0d4a3bec1a5ae09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a31ed0c3e4cdb5479e0d4a3bec1a5ae09">Bonmin::TMINLP::VariableType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the variables. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a31ed0c3e4cdb5479e0d4a3bec1a5ae09a07ad1737d2861f380390698a018afb40"></a><!-- doxytag: member="CONTINUOUS" ref="a31ed0c3e4cdb5479e0d4a3bec1a5ae09a07ad1737d2861f380390698a018afb40" args="" -->CONTINUOUS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a31ed0c3e4cdb5479e0d4a3bec1a5ae09ad73b3452f6e6aee8659d854a1803a73b"></a><!-- doxytag: member="BINARY" ref="a31ed0c3e4cdb5479e0d4a3bec1a5ae09ad73b3452f6e6aee8659d854a1803a73b" args="" -->BINARY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a31ed0c3e4cdb5479e0d4a3bec1a5ae09a47f6c2e4d46ac39986728bf2adf419c2"></a><!-- doxytag: member="INTEGER" ref="a31ed0c3e4cdb5479e0d4a3bec1a5ae09a47f6c2e4d46ac39986728bf2adf419c2" args="" -->INTEGER</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00192">192</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a578ad3281073969b2751c577835872"></a><!-- doxytag: member="Bonmin::TMINLP::Convexity" ref="a1a578ad3281073969b2751c577835872" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a1a578ad3281073969b2751c577835872">Bonmin::TMINLP::Convexity</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to mark constraints of the problem. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1a578ad3281073969b2751c577835872a9f24551f3b3830c058baefee74bbed24"></a><!-- doxytag: member="Convex" ref="a1a578ad3281073969b2751c577835872a9f24551f3b3830c058baefee74bbed24" args="" -->Convex</em>&nbsp;</td><td>
<p>Constraint is convex. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1a578ad3281073969b2751c577835872a2f1f415ce8e21ffcb3c43b83aad76ddd"></a><!-- doxytag: member="NonConvex" ref="a1a578ad3281073969b2751c577835872a2f1f415ce8e21ffcb3c43b83aad76ddd" args="" -->NonConvex</em>&nbsp;</td><td>
<p>Constraint is non-convex. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1a578ad3281073969b2751c577835872a64065b9c897f109cc5e4e394e074e940"></a><!-- doxytag: member="SimpleConcave" ref="a1a578ad3281073969b2751c577835872a64065b9c897f109cc5e4e394e074e940" args="" -->SimpleConcave</em>&nbsp;</td><td>
<p>Constraint is concave of the simple form y &gt;= F(x). </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00348">348</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab47c82ceca30aa9ebffd97442b74f0f3"></a><!-- doxytag: member="Bonmin::TMINLP::TMINLP" ref="ab47c82ceca30aa9ebffd97442b74f0f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bonmin::TMINLP::TMINLP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a class="anchor" id="a7b0df23b5d25380acd2358bae697f699"></a><!-- doxytag: member="Bonmin::TMINLP::~TMINLP" ref="a7b0df23b5d25380acd2358bae697f699" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Bonmin::TMINLP::~TMINLP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a class="anchor" id="ab0e51c30424dca9eeae277119d3abf58"></a><!-- doxytag: member="Bonmin::TMINLP::TMINLP" ref="ab0e51c30424dca9eeae277119d3abf58" args="(const TMINLP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bonmin::TMINLP::TMINLP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html">TMINLP</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copy Constructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afe3e7dc4d980a18aa5ece4168d98e235"></a><!-- doxytag: member="Bonmin::TMINLP::get_nlp_info" ref="afe3e7dc4d980a18aa5ece4168d98e235" args="(Ipopt::Index &amp;n, Ipopt::Index &amp;m, Ipopt::Index &amp;nnz_jac_g, Ipopt::Index &amp;nnz_h_lag, Ipopt::TNLP::IndexStyleEnum &amp;index_style)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_nlp_info </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index &amp;&#160;</td>
          <td class="paramname"><em>nnz_jac_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index &amp;&#160;</td>
          <td class="paramname"><em>nnz_h_lag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::TNLP::IndexStyleEnum &amp;&#160;</td>
          <td class="paramname"><em>index_style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the number of variables and constraints, and the number of non-zeros in the jacobian and the hessian. </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#a635addd6316d0041c4fd544e5757611d">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#adb1389eadf0f687f30fedce82a3b3002">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="a740751ce6ef284604def22fb6e587ea3"></a><!-- doxytag: member="Bonmin::TMINLP::get_scaling_parameters" ref="a740751ce6ef284604def22fb6e587ea3" args="(Ipopt::Number &amp;obj_scaling, bool &amp;use_x_scaling, Ipopt::Index n, Ipopt::Number *x_scaling, bool &amp;use_g_scaling, Ipopt::Index m, Ipopt::Number *g_scaling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_scaling_parameters </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Number &amp;&#160;</td>
          <td class="paramname"><em>obj_scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>use_x_scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x_scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>use_g_scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>g_scaling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return scaling parameters. </p>
<p>This is only called if the options are set to retrieve user scaling. There, use_x_scaling (or use_g_scaling) should get set to true only if the variables (or constraints) are to be scaled. This method should return true only if the scaling parameters could be provided. </p>

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a396f391b3ca2d91be4f6807db98dcd30">Bonmin::TMINLPLinObj</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00222">222</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a34a3b8f55889ede85929f8ff4fc870"></a><!-- doxytag: member="Bonmin::TMINLP::get_variables_types" ref="a8a34a3b8f55889ede85929f8ff4fc870" args="(Ipopt::Index n, VariableType *var_types)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_variables_types </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a31ed0c3e4cdb5479e0d4a3bec1a5ae09">VariableType</a> *&#160;</td>
          <td class="paramname"><em>var_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to provide the variables types. </p>
<p>The var_types array will be allocated with length n. </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#af8ec128a457061f1f4f379d5cc541875">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#afb88e9eae6e4a4f02c85bd5d30f5f686">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="a4e01017190e373ebe8324074800c043f"></a><!-- doxytag: member="Bonmin::TMINLP::get_variables_linearity" ref="a4e01017190e373ebe8324074800c043f" args="(Ipopt::Index n, Ipopt::TNLP::LinearityType *var_types)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_variables_linearity </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::TNLP::LinearityType *&#160;</td>
          <td class="paramname"><em>var_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to provide the variables linearity. </p>
<p>array should be allocated with length at least n. </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a8c544220ee5d8444b76e23aceca0632e">Bonmin::TMINLPLinObj</a>, and <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#a9bb72a0963c5bfec3f8fb78974ac67c0">Bonmin::AmplTMINLP</a>.</p>

</div>
</div>
<a class="anchor" id="a576125a75942898fd2a584b1c3510388"></a><!-- doxytag: member="Bonmin::TMINLP::get_constraints_linearity" ref="a576125a75942898fd2a584b1c3510388" args="(Ipopt::Index m, Ipopt::TNLP::LinearityType *const_types)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_constraints_linearity </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::TNLP::LinearityType *&#160;</td>
          <td class="paramname"><em>const_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to provide the constraint linearity. </p>
<p>array should be allocated with length at least m. </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#a1da2ffdc3dee05109db896df6b24e347">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a7da55767b43be9ce05c1a1259af4d3b9">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="a71056c07ab8a4ce38d0571f281933688"></a><!-- doxytag: member="Bonmin::TMINLP::get_bounds_info" ref="a71056c07ab8a4ce38d0571f281933688" args="(Ipopt::Index n, Ipopt::Number *x_l, Ipopt::Number *x_u, Ipopt::Index m, Ipopt::Number *g_l, Ipopt::Number *g_u)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_bounds_info </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>g_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>g_u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the information about the bound on the variables and constraints. </p>
<p>The value that indicates that a bound does not exist is specified in the parameters nlp_lower_bound_inf and nlp_upper_bound_inf. By default, nlp_lower_bound_inf is -1e19 and nlp_upper_bound_inf is 1e19. An exception will be thrown if x_l and x_u are not 0,1 for binary variables </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#a602b5cc13ac14850410eb4bc5b978b24">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a1dc751c5e26b5370b1047b4570721699">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="a916ccc55b7ea1ee4daddc4608389cdda"></a><!-- doxytag: member="Bonmin::TMINLP::get_starting_point" ref="a916ccc55b7ea1ee4daddc4608389cdda" args="(Ipopt::Index n, bool init_x, Ipopt::Number *x, bool init_z, Ipopt::Number *z_L, Ipopt::Number *z_U, Ipopt::Index m, bool init_lambda, Ipopt::Number *lambda)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_starting_point </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>z_L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>z_U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the starting point. </p>
<p>The bools init_x and init_lambda are both inputs and outputs. As inputs, they indicate whether or not the algorithm wants you to initialize x and lambda respectively. If, for some reason, the algorithm wants you to initialize these and you cannot, set the respective bool to false. </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#a980d962bf6e0c9b924919f083a2bf46f">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#adc90505ee2e50c7decd9588a4ae19d24">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="adb99e4c1f8e08afdb786b290d680c06b"></a><!-- doxytag: member="Bonmin::TMINLP::eval_f" ref="adb99e4c1f8e08afdb786b290d680c06b" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number &amp;obj_value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::eval_f </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number &amp;&#160;</td>
          <td class="paramname"><em>obj_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the value of the objective function </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#aebc254e3becc17c7b6a0e19964be2a5a">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#ab315970ff83c8ba4b2e3fe94c4fa19b7">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="aa796b8a447d261fc32b41dfe8a24a6d4"></a><!-- doxytag: member="Bonmin::TMINLP::eval_grad_f" ref="aa796b8a447d261fc32b41dfe8a24a6d4" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number *grad_f)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::eval_grad_f </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>grad_f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the vector of the gradient of the objective w.r.t. </p>
<p>x </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ad87091b7ddb97d5d8441a03196e3da64">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a2a8ac13a216befe0ff3d0b1790377394">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="a68b3a747f68fbec612216cd40426857f"></a><!-- doxytag: member="Bonmin::TMINLP::eval_g" ref="a68b3a747f68fbec612216cd40426857f" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Number *g)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::eval_g </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the vector of constraint values </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ae46f1ddbcd974768be1c9148b356fd2f">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#aa2db57bd69f6838d5645d1e1d375f3b9">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="a7d0a1f22939a9257a528a8bef98ff3b2"></a><!-- doxytag: member="Bonmin::TMINLP::eval_jac_g" ref="a7d0a1f22939a9257a528a8bef98ff3b2" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Index nele_jac, Ipopt::Index *iRow, Ipopt::Index *jCol, Ipopt::Number *values)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::eval_jac_g </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>nele_jac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index *&#160;</td>
          <td class="paramname"><em>iRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index *&#160;</td>
          <td class="paramname"><em>jCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the jacobian of the constraints. </p>
<p>The vectors iRow and jCol only need to be set once. The first call is used to set the structure only (iRow and jCol will be non-NULL, and values will be NULL) For subsequent calls, iRow and jCol will be NULL. </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#aeb4e9b05afd87ff3a2aec1928f1cb7a5">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#aef93bfd850ed777d0354686098210dcd">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="a88dcf938655472809afd0586e399d0ec"></a><!-- doxytag: member="Bonmin::TMINLP::eval_h" ref="a88dcf938655472809afd0586e399d0ec" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number obj_factor, Ipopt::Index m, const Ipopt::Number *lambda, bool new_lambda, Ipopt::Index nele_hess, Ipopt::Index *iRow, Ipopt::Index *jCol, Ipopt::Number *values)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::eval_h </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number&#160;</td>
          <td class="paramname"><em>obj_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>nele_hess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index *&#160;</td>
          <td class="paramname"><em>iRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index *&#160;</td>
          <td class="paramname"><em>jCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the hessian of the lagrangian. </p>
<p>The vectors iRow and jCol only need to be set once (during the first call). The first call is used to set the structure only (iRow and jCol will be non-NULL, and values will be NULL) For subsequent calls, iRow and jCol will be NULL. This matrix is symmetric - specify the lower diagonal only </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#a68d6625d6e7632f8214d14f9059b51b9">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a2f681ddbaa81ddd77598986fe9e9b2b5">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="a10e3dcd09b90c6c38f307082ac5af60c"></a><!-- doxytag: member="Bonmin::TMINLP::eval_gi" ref="a10e3dcd09b90c6c38f307082ac5af60c" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index i, Ipopt::Number &amp;gi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::eval_gi </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number &amp;&#160;</td>
          <td class="paramname"><em>gi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the value of a single constraint. </p>
<p>The constraint number is i (starting counting from 0. </p>

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ab0599ec6076d910f90b15925a619e411">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#adaaeefe31868414e5ec4716ad8c8f807">Bonmin::TMINLPLinObj</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00304">304</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08432792778b26b6f81c92b678d775bd"></a><!-- doxytag: member="Bonmin::TMINLP::eval_grad_gi" ref="a08432792778b26b6f81c92b678d775bd" args="(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index i, Ipopt::Index &amp;nele_grad_gi, Ipopt::Index *jCol, Ipopt::Number *values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::eval_grad_gi </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index &amp;&#160;</td>
          <td class="paramname"><em>nele_grad_gi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index *&#160;</td>
          <td class="paramname"><em>jCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the structure or values of the gradient for one constraint. </p>
<p>The constraint * number is i (starting counting from 0. Other things are like with eval_jac_g. </p>

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ad2a46d79d19f9c5e5d8b7e32ec6fe145">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a8c387d78a97f32955eac66351fc8fc24">Bonmin::TMINLPLinObj</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00313">313</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a492d05e99cfb915922c933ecae9ed1ab"></a><!-- doxytag: member="Bonmin::TMINLP::finalize_solution" ref="a492d05e99cfb915922c933ecae9ed1ab" args="(TMINLP::SolverReturn status, Ipopt::Index n, const Ipopt::Number *x, Ipopt::Number obj_value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Bonmin::TMINLP::finalize_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#af637b1924c8559f56075e39448dd12aa">TMINLP::SolverReturn</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number&#160;</td>
          <td class="paramname"><em>obj_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is called when the algorithm is complete so the TNLP can store/write the solution. </p>

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ac082403528a4e67e52a95f3a727f87c8">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a0de4c834d174460ce0640a2ff85caea8">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="a0411c4f260997488ac7730844da708e0"></a><!-- doxytag: member="Bonmin::TMINLP::branchingInfo" ref="a0411c4f260997488ac7730844da708e0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_branching_info.html">BranchingInfo</a>* Bonmin::TMINLP::branchingInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#a0f1346f787affcd5d3feb8fcc2c25d40">Bonmin::AmplTMINLP</a>, <a class="el" href="class_my_t_m_i_n_l_p.html#a7f23618c2151a965ba8af72cc274f39c">MyTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a57ccc9329929f7adb8b94b11865c9b99">Bonmin::TMINLPLinObj</a>.</p>

</div>
</div>
<a class="anchor" id="acd6b2feac68461ea9017e66897f21e90"></a><!-- doxytag: member="Bonmin::TMINLP::sosConstraints" ref="acd6b2feac68461ea9017e66897f21e90" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_sos_info.html">SosInfo</a>* Bonmin::TMINLP::sosConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ace2dfbd0cd317f5296a01a730ab092f5">Bonmin::AmplTMINLP</a>, <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a47754e87ce7a66827bbb94c87f613ad0">Bonmin::TMINLPLinObj</a>, and <a class="el" href="class_my_t_m_i_n_l_p.html#ae5f4bd6478e608d83f4915bc6b9b38e0">MyTMINLP</a>.</p>

</div>
</div>
<a class="anchor" id="a8de73cde089588281f08b5efc6fa7bca"></a><!-- doxytag: member="Bonmin::TMINLP::perturbInfo" ref="a8de73cde089588281f08b5efc6fa7bca" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_1_1_perturb_info.html">PerturbInfo</a>* Bonmin::TMINLP::perturbInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ac4408c6847ea36b9db1b335898a9adaa">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a5ff7107629a5c3d56b5a4f34ac34d394">Bonmin::TMINLPLinObj</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00333">333</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46d0ccf29f7f0a6ab0e407d0f59c9fc3"></a><!-- doxytag: member="Bonmin::TMINLP::hasUpperBoundingObjective" ref="a46d0ccf29f7f0a6ab0e407d0f59c9fc3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::hasUpperBoundingObjective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Say if has a specific function to compute upper bounds. </p>

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#af6e96378372c96f269838fabc46c0ce5">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a65d0826b20acacc99ff3d3ba4ca806fd">Bonmin::TMINLPLinObj</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00339">339</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e561bc269d70d94457ae0bf9849f383"></a><!-- doxytag: member="Bonmin::TMINLP::eval_upper_bound_f" ref="a6e561bc269d70d94457ae0bf9849f383" args="(Ipopt::Index n, const Ipopt::Number *x, Ipopt::Number &amp;obj_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::eval_upper_bound_f </td>
          <td>(</td>
          <td class="paramtype">Ipopt::Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ipopt::Number *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipopt::Number &amp;&#160;</td>
          <td class="paramname"><em>obj_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>overload this method to return the value of an alternative objective function for upper bounding (to use it hasUpperBoundingObjective should return true). </p>

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ae0f81500bee36c4afd28ca96fda87aa9">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a5786752415464d4050e6e182641ec6f3">Bonmin::TMINLPLinObj</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00344">344</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad06ab84cbdd03fcda2987b5bb22ae287"></a><!-- doxytag: member="Bonmin::TMINLP::get_constraint_convexities" ref="ad06ab84cbdd03fcda2987b5bb22ae287" args="(int m, TMINLP::Convexity *constraints_convexities) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_constraint_convexities </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html#a1a578ad3281073969b2751c577835872">TMINLP::Convexity</a> *&#160;</td>
          <td class="paramname"><em>constraints_convexities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get accest to constraint convexities. </p>

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ad63d3277db12b13f272c214e29c1be66">Bonmin::AmplTMINLP</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00377">377</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

<p>References <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00349">Convex</a>.</p>

</div>
</div>
<a class="anchor" id="af1185094c0a8d14b23f48478e80fa9d4"></a><!-- doxytag: member="Bonmin::TMINLP::get_number_nonconvex" ref="af1185094c0a8d14b23f48478e80fa9d4" args="(int &amp;number_non_conv, int &amp;number_concave) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_number_nonconvex </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>number_non_conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>number_concave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get dimension information on nonconvex constraints. </p>

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#a3f5b5d1f4d950d42e2671bf3cd553757">Bonmin::AmplTMINLP</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00381">381</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59fdbfe7e50ac4c0904b3c4c77735c23"></a><!-- doxytag: member="Bonmin::TMINLP::get_constraint_convexities" ref="a59fdbfe7e50ac4c0904b3c4c77735c23" args="(int number_non_conv, MarkedNonConvex *non_convs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_constraint_convexities </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_non_conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_marked_non_convex.html">MarkedNonConvex</a> *&#160;</td>
          <td class="paramname"><em>non_convs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get array describing the constraints marked nonconvex in the model. </p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00386">386</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4cbe58a5ec3fabaf15cc721740d52a8"></a><!-- doxytag: member="Bonmin::TMINLP::get_simple_concave_constraints" ref="aa4cbe58a5ec3fabaf15cc721740d52a8" args="(int number_concave, SimpleConcaveConstraint *simple_concave) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::get_simple_concave_constraints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number_concave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bonmin_1_1_t_m_i_n_l_p_1_1_simple_concave_constraint.html">SimpleConcaveConstraint</a> *&#160;</td>
          <td class="paramname"><em>simple_concave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill array containing indices of simple concave constraints. </p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00390">390</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d11768108279a123da4ba254d62b683"></a><!-- doxytag: member="Bonmin::TMINLP::hasLinearObjective" ref="a3d11768108279a123da4ba254d62b683" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Bonmin::TMINLP::hasLinearObjective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Say if problem has a linear objective (for OA) </p>

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#ad7c3dad556bea8f01507e3c15478bd90">Bonmin::AmplTMINLP</a>, and <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p_lin_obj.html#a069d17c878d9afde8ba75cc21603e2fe">Bonmin::TMINLPLinObj</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00395">395</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ced9cfd6a40dc99b6d441b10c9a2ed5"></a><!-- doxytag: member="Bonmin::TMINLP::hasGeneralInteger" ref="a8ced9cfd6a40dc99b6d441b10c9a2ed5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Bonmin::TMINLP::hasGeneralInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Say if problem has general integer variables. </p>

</div>
</div>
<a class="anchor" id="a8aa206c04ebd20610d9f196796f1ab2d"></a><!-- doxytag: member="Bonmin::TMINLP::get_const_xtra_id" ref="a8aa206c04ebd20610d9f196796f1ab2d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const int* Bonmin::TMINLP::get_const_xtra_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access array describing constraint to which perspectives should be applied. </p>

<p>Reimplemented in <a class="el" href="class_bonmin_1_1_ampl_t_m_i_n_l_p.html#a0e5aea5fac3a1a47dac044b4e15cb44a">Bonmin::AmplTMINLP</a>.</p>

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00401">401</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12a8af7768290187f961564a582162c9"></a><!-- doxytag: member="Bonmin::TMINLP::operator=" ref="a12a8af7768290187f961564a582162c9" args="(const TMINLP &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bonmin::TMINLP::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p.html">TMINLP</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded Equals Operator. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a65bff206a7e91288f5ec46e0b8990c86"></a><!-- doxytag: member="Bonmin::TMINLP::TMINLP2TNLP" ref="a65bff206a7e91288f5ec46e0b8990c86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_bonmin_1_1_t_m_i_n_l_p2_t_n_l_p.html">TMINLP2TNLP</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html#l00062">62</a> of file <a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_bon_t_m_i_n_l_p_8hpp_source.html">BonTMINLP.hpp</a></li>
</ul>
</div>


<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
